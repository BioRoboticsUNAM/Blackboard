using System;
using System.Collections.Generic;
using System.Net;
using System.Net.Sockets;
using System.Text.RegularExpressions;
using System.Threading;

namespace BlackboardApi
{
	#region Delegados
	/// <summary>
	/// Represents the method that will handle the Connected and Disconnected event of a ModuleClient object.
	/// </summary>
	/// <param name="m">ModuleClient connected/disconnected</param>
	public delegate void ModuleConnectionEH(ModuleClient m);

	/// <summary>
	/// Represents the method that will handle the CommandReceived event of a ModuleClient object.
	/// </summary>
	/// <param name="sender">The module where the command has arrived</param>
	/// <param name="c">Command received</param>
	public delegate void CommandReceivedEH(ModuleClient sender, Command c);

	/// <summary>
	/// Represents the method that will handle the ResponseReceived event of a ModuleClient object.
	/// </summary>
	/// <param name="sender">The module where the response has arrived</param>
	/// <param name="r">Response received</param>
	public delegate void ResponseReceivedEH(ModuleClient sender, Response r);
	#endregion

	/// <summary>
	/// Implements a ModuleClient
	/// </summary>
	public class ModuleClient : IModule
	{
		#region Variables
		/// <summary>
		/// Module name
		/// </summary>
		private string name;
		/// <summary>
		/// The blackboard this module is bind to
		/// </summary>
		internal Blackboard parent;
		/// <summary>
		/// List of the command prototypes supported by the Application Module
		/// </summary>
		private MessagePrototypeCollection prototypes;
		/// <summary>
		/// Thread for connecting to remote application and perform async tasks
		/// </summary>
		private Thread mainThread;

		#region Message flow vars

		/// <summary>
		/// Tells if the module is busy
		/// </summary>
		private bool busy;
		/*
		/// <summary>
		/// List of commands waiting for a response
		/// </summary>
		private List<Command> waitingResponse;
		/// <summary>
		/// List of responses received
		/// </summary>
		private List<Response> responses;
		/// <summary>
		/// List of commands received
		/// </summary>
		private List<Command> commands;
		*/
		#endregion

		#region Socket and connection vars

		/// <summary>
		/// Connection socket to the Application Module
		/// </summary>
		private SocketTcpClient client;
		/// <summary>
		/// IP Address of Application Module's computer
		/// </summary>
		private IPAddress ip;
		/// <summary>
		/// Port to connect to the Application ModuleServer
		/// </summary>
		private int port;
		/// <summary>
		/// Indicates if the ModuleClient is runnuing
		/// </summary>
		private bool running;

		#endregion

		#endregion

		#region Constructores

		/// <summary>
		/// Initializes a new instance of the ModuleClient class 
		/// </summary>
		/// <param name="name">Module name</param>
		/// <param name="ip">IP Address of Application Module's computer</param>
		/// <param name="port">Port of the Application Module</param>
		internal ModuleClient(string name, IPAddress ip, int port)
		{
			if ((port < 1024) || (port > 65535)) throw new ArgumentException("Port must be between 1024 and 65535", "port");
			if (!Regex.IsMatch(name, @"\w[\w\-_\d]{2,}")) throw new ArgumentException("Invalid module name", "name");
			this.name = name;
			this.ip = ip;
			this.port = port;
			this.busy = false;
			//this.waitingResponse = new List<Command>(10);
			//this.responses = new List<Response>();
			//this.commands = new List<Command>();
			this.prototypes = new MessagePrototypeCollection(this);
		}

		/// <summary>
		/// Initializes a new instance of the ModuleClient class 
		/// </summary>
		/// <param name="name">Module name</param>
		/// <param name="ip">IP Address of Application Module's computer</param>
		/// <param name="port">Port of the Application Module</param>
		/// <param name="prototypes">List of the command prototypes supported by the Application Module</param>
		public ModuleClient(string name, IPAddress ip, int port, Prototype[] prototypes) : this(name, ip, port)
		{
			if ((prototypes == null) || (prototypes.Length == 0)) throw new ArgumentException("The prototypes list cannot be zero-length nor null");
			for (int i = 0; i < prototypes.Length; ++i)
				this.prototypes.Add(prototypes[i]);
		}

		#endregion

		#region Propiedades

		/// <summary>
		/// Gets a value indicating if the current module is busy (waiting for a response)
		/// </summary>
		public bool Busy
		{
			get
			{
				return busy;
			}
		}
		
		/// <summary>
		/// Tells if the connection to the ModuleServer has been stablished
		/// </summary>
		public bool IsConnected
		{
			get
			{
				if (client != null)
					return client.IsOpen;
				return false;
			}
		}
		
		/// <summary>
		/// Gets the name of the Module
		/// </summary>
		public string Name
		{
			get { return name; }
		}

		/// <summary>
		/// Gets the blackboard this ModuleClient is bind to
		/// </summary>
		public Blackboard Parent
		{
			get { return parent; }
		}

		/// <summary>
		/// Gets the port where to connect to the Application Module
		/// </summary>
		public int Port
		{
			get { return port; }
		}

		/// <summary>
		/// Gets the prototypes managed by the Module
		/// </summary>
		public MessagePrototypeCollection Prototypes
		{
			get
			{
				return prototypes;
			}
		}

		/// <summary>
		/// Gets the IP Address of Application Module's computer
		/// </summary>
		public IPAddress ServerAddress
		{
			get { return ip; }
		}

		#endregion

		#region Eventos

		/// <summary>
		/// Occurs when the ModuleClient connects to a Tcp Server
		/// </summary>
		public event ModuleConnectionEH Connected;

		/// <summary>
		/// Occurs when the ModuleClient disconnects from a Tcp Server
		/// </summary>
		public event ModuleConnectionEH Disconnected;

		/// <summary>
		/// Occurs when a Command is received trough socket
		/// </summary>
		public event CommandReceivedEH CommandReceived;

		/// <summary>
		/// Occurs when a Response is received trough socket
		/// </summary>
		public event ResponseReceivedEH ResponseReceived;

		#endregion

		#region Metodos

		#region To check
		/*

		/// <summary>
		/// Checks if the response for the provided command has arrived
		/// </summary>
		/// <param name="command">The command for which response to look for</param>
		/// <param name="response">When this method returns, contains the response for the command provided if fount, or null if the response was not found.
		/// The search fails if the command parameter is a null reference (Nothing in Visual Basic), or the response was not found. This parameter is passed uninitialized. </param>
		/// <returns>true if the response has been found, false otherwise</returns>
		private bool CheckForResponse(Command command, out Response response)
		{
			response = null;
			if (command == null) return false;
			foreach (Response r in responses)
			{
				if ((r.Command == command.Command) && (r.Id == command.Id))
				{
					response = r;
					return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Synchronously sends a command to the module and waits for the response
		/// </summary>
		/// <param name="command">Command to send</param>
		/// <returns>Returns the response to the command</returns>
		public Response Send(Command command)
		{
			Response r;
			// Check if the module represented by this ModuleClient is the destination module for the command
			if (this != command.Destination)
				throw new Exception("Command marked to be sent through other module");
			// Check is connection has been stablished.
			if (!client.IsOpen)
				return Response.CreateFromCommand(command, false);
			// Check if module is not busy and command is not a priority command
			if(busy && !command.Prototype.HasPriority)
				return Response.CreateFromCommand(command, false);
			// Send the command
			try { client.Send(command.StringToSend + "\0"); }
			catch { return Response.CreateFromCommand(command, false); }
			command.SentTime = DateTime.Now;
			// If no response is required a success generic response is returned
			if(!command.Prototype.ResponseRequired)
				return Response.CreateFromCommand(command, true);
			// Add command to Waiting list
			waitingResponse.Add(command);
			// Wait untill response is received or timeout occur.
			while(command.MillisecondsLeft > 0)
			{
				Thread.Sleep(10);
				if (CheckForResponse(command, out r))
					return r;
			}
			// Since there is a TimeOut (i.e. no response received) a failed generic response is returned
			return Response.CreateFromCommand(command, false);
		}

		*/
		#endregion

		/// <summary>
		/// Sends a command to the module
		/// </summary>
		/// <param name="command">Response to send</param>
		/// <returns>true if the command has been sent, false otherwise</returns>
		public bool Send(Command command)
		{
			// Check if this module is the destination module for the command
			if (this != command.Destination)
				throw new Exception("Command marked to be sent through other module");
			// Check is connection has been stablished.
			if (!client.IsOpen)
				return false;
			// Check if module is not busy and command is not a priority command
			if (busy && !command.Prototype.HasPriority)
				return false;
			// Send the command
			try { client.Send(command.StringToSend + "\0"); }
			catch { return false; }
			return true;
		}

		/// <summary>
		/// Synchronusly sends a command response to the module
		/// </summary>
		/// <param name="response">Response to send</param>
		/// <returns>true if the response has been sent, false otherwise</returns>
		public bool Send(Response response)
		{
			// Check if this module is the destination module for the response
			if (this != response.Destination)
				throw new Exception("Response marked to be sent through other module");
			// Check is connection has been stablished.
			if (!client.IsOpen)
				return false;
			// Send the response
			try { client.Send(response.StringToSend + "\0"); }
			catch { return false; }
			return true;
		}
		
		/// <summary>
		/// Initializes the thread for autoconnection to ModuleServer
		/// If the server is running starts the thread automatically
		/// </summary>
		private void SetupMainThread()
		{
			if (mainThread != null) mainThread.Abort();
			mainThread = new Thread(new ParameterizedThreadStart(MainThreadTask));
			mainThread.IsBackground = true;
			if(running) mainThread.Start();
		}

		/// <summary>
		/// Initializes the socket
		/// </summary>
		private void setupSocket()
		{
			client = new SocketTcpClient(ServerAddress, Port);
			client.Connected += new TcpClientConnectedEventHandler(client_Connected);
			client.Disconnected += new TcpClientConnectedEventHandler(client_Disconnected);
			client.DataReceived += new TcpDataReceivedEventHandler(client_DataReceived);
		}

		/// <summary>
		/// Returns a value indicating if the command is supported by this module
		/// </summary>
		/// <param name="commandName">The name of the command to search for</param>
		/// <returns>True if the command was found. false otherwise</returns>
		public bool SupportCommand(string commandName)
		{
			if ((commandName == null) || !Regex.IsMatch(commandName, @"[A-Za-z_]+")) return false;
			commandName = commandName.ToLower();
			foreach (Prototype p in prototypes)
				if (p.Command == commandName)
					return true;
			return false;
		}

		/// <summary>
		/// Returns a value indicating if the command is supported by this module
		/// </summary>
		/// <param name="commandName">The name of the command to search for</param>
		/// <param name="prototype">When this method returns, contains the Prototype that brings support to this command
		/// if the search succeeded, or null if the module does not supports the command.
		/// The conversion fails if the s parameter is a null reference (Nothing in Visual Basic) or is not of the correct format.
		/// This parameter is passed uninitialized</param>
		/// <returns>True if the command was found. false otherwise</returns>
		public bool SupportCommand(string commandName, out Prototype prototype)
		{
			prototype = null;
			if ((commandName == null) || !Regex.IsMatch(commandName, @"[A-Za-z_]+")) return false;
			commandName = commandName.ToLower();
			foreach (Prototype p in prototypes)
			{
				if (p.Command == commandName)
				{
					prototype = p;
					return true;
				}
			}
			return false;
		}

		/// <summary>
		/// Connect to the remote application and starts the command management system.
		/// If the ModuleClient is already running, it has no effect.
		/// </summary>
		public void Start()
		{
			if (running) return;
			running = true;
			if ((client != null) && (client.IsOpen))
				client.Disconnect();
			setupSocket();
			SetupMainThread();
		}

		/// <summary>
		/// Disconnects from remote application and stops command management system.
		/// If the ModuleClient is not running, it has no effect.
		/// </summary>
		public void Stop()
		{
			if (!running) return;
			if (mainThread != null)
			{
				mainThread.Abort();
				mainThread = null;
			}

			while (client.IsOpen)
			{
				client.Disconnect();
				Thread.Sleep(10);
			}
			client = null;
			running = false;
		}

		/// <summary>
		/// Returns a String that represents the current ModuleClient. 
		/// </summary>
		/// <returns>A String that represents the current ModuleClient</returns>
		public override string ToString()
		{
			return name + " [" + ip.ToString() + ":" + port.ToString() + "]";
		}

		#endregion

		#region Event Handler Functions

		/// <summary>
		/// Thread for autoconnect to remote application
		/// </summary>
		/// <param name="sender">Unused</param>
		private void MainThreadTask(object sender)
		{
			while (running)
			{
				// Autoconnect
				if (!client.IsOpen)
				{
					client.TryConnect();
					Thread.Sleep(250);
					continue;
				}
			    Thread.Sleep(250);
			}
			mainThread.Abort();
			mainThread.Join();
			mainThread = null;
		}

		#region Socket Event Handler Functions

		/// <summary>
		/// Performs operations when the connection to remote application is stablished
		/// </summary>
		/// <param name="s">Socket used for connection</param>
		private void client_Connected(Socket s)
		{
			busy = false;
			if (Connected != null)
				Connected(this);
		}

		/// <summary>
		/// Performs operations when the connection to remote application has ended
		/// </summary>
		/// <param name="s">Socket used for connection</param>
		private void client_Disconnected(Socket s)
		{
			if (Disconnected != null)
				Disconnected(this);
			busy = false;
		}

		/// <summary>
		/// Performs operations when data is received trough socket
		/// </summary>
		/// <param name="p">TCP Packet received</param>
		private void client_DataReceived(TcpPacket p)
		{
			string message;
			Command c;
			Response r;

			message = p.DataString.Trim();
			// Check if message received is a command
			if (Command.IsCommand(message) && Command.TryParse(message, this, out c))
			{
				// A command has been received so it is redirected to blackboard
				if (CommandReceived != null)
					CommandReceived(this, c);
			}
			// Check if message received is a response
			else if (Response.IsResponse(message) && Response.TryParse(message, this, out r))
			{
				// A response has been received so it is redirected to blackboard
				if (ResponseReceived != null)
					ResponseReceived(this, r);
			}
		}

		#endregion

		#endregion

		#region Metodos de Clase (Estáticos)

		/// <summary>
		/// Parses a module from a string
		/// </summary>
		/// <param name="s">String to parse</param>
		/// <returns>The module connection gateway or null if parse failed</returns>
		public static ModuleClient FromString(string s)
		{
			//string rxName = @"(?<name>[a-zA-Z_][a-zA-Z0-9\-_]*)";
			string rxName = @"(?<name>[A-Z][A-Z\-]*)";
			string rxIP = @"(?<ip>(\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}))";
			string rxSpace = @"[\t ]+";
			string rxPort = @"(?<port>(\d{3,5}))?[\t ]*(?<readonly>(readonly|read only))?";
			Match result;
			IPAddress ip;
			int port;

			Regex rx = new Regex(@"module" + rxSpace + rxName + rxSpace + rxIP + rxSpace + rxPort, RegexOptions.Compiled);
			result = rx.Match(s.Trim());
			if (!result.Success) return null;
			if (!IPAddress.TryParse(result.Result("${ip}"), out ip)) return null;
			if (result.Result("${readonly}") != "")
				port = 0;
			else if (!Int32.TryParse(result.Result("${port}"), out port)) return null;
			//result.Result("${name},${ip},${port}").Split(new char[] {','});
			return new ModuleClient(result.Result("${name}"), ip, port, null);
			
		}

		#endregion

		#region IComparable<IModule> Members

		/// <summary>
		/// Compares the current ModuleClient with another object of the same type.
		/// </summary>
		/// <param name="other">An object to compare with this object</param>
		/// <returns>A 32-bit signed integer that indicates the relative order of the objects being compared.</returns>
		public int CompareTo(IModule other)
		{
			return name.CompareTo(other.Name);
		}

		#endregion
	}
}
